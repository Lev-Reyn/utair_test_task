CREATE DATABASE IF NOT EXISTS dm;

CREATE TABLE IF NOT EXISTS dm.telemetry(
    aircraft_id String COMMENT 'ID борта',
    flight_id String COMMENT 'ID рейса/рейс',
    timestamp DateTime COMMENT 'время события',
    event_date Date MATERIALIZED toDate(timestamp) COMMENT 'дата события',
    parameter String COMMENT 'наименование параметра',
    value Float64 COMMENT 'значение параметра',
    to_ts DateTime64(9) DEFAULT now64(9) COMMENT 'время появления записи в clickHouse'
)
ENGINE = ReplicatedMergeTree(
    '/clickhouse/tables/{shard}/dm.telemetry',
    '{replica}'
)
PARTITION BY toYYYYMM(timestamp)
ORDER BY (aircraft_id, flight_id, timestamp, parameter)
TTL timestamp + INTERVAL 37 MONTH DELETE
;

-- обоснование движка:
    -- нам нужно будет схлапывать относительно частые insert,
    -- необходимы реплики для отказоустойчивости,
    -- данные изменяться у нас не будут, это не возраст человека который меняется, а телеметрия которая какая пришла, такая она и есть
-- обоснование партиционирования:
    -- предполагаю, что данные по телеметрии будут хранится около трёх лет, а значит если будем партиционировать по дням, то будет более 1000 партиций, что не рекомендуется
    -- партиционировние по месяцам не вызовет большого скопления файлов, по истечению необходимого срока хранения легко удалять партиции
    -- быстрая отработка аналитических запросов за месяц и квартал
-- обоснование ключа сортировки:
    -- выбрал все поля именно в таком порядке, так как вероятно запросы будут строиться по конкретным бортам и рейсам, а не параметрам, так как смотреть параметры за последние n минут разных бортов не имеет смысла, в отличие от смотреть по отдельности за конкретный борт
-- TTL:
    -- автоматическое удаление устаревших данных более трёх лет



-- загрузку данных организовал бы используя kafka, загрузка батчей за n миннут, что бы у нас не накопилось большого кол-ва партов в clickHouse


